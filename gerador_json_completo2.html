<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Gerador de JSON de Tipos Duplos (Com Redundâncias)</title>
    <style>
        body { font-family: sans-serif; background-color: #f0f0f0; color: #333; max-width: 90%; margin: 20px auto; padding: 20px; }
        h1 { text-align: center; }
        button { display: block; width: 350px; padding: 15px; font-size: 18px; margin: 20px auto; cursor: pointer; background-color: #28a745; color: white; border: none; border-radius: 5px; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #status { text-align: center; font-style: italic; color: #555; margin-bottom: 20px; }
        textarea { width: 100%; height: 60vh; margin-top: 10px; font-family: monospace; font-size: 14px; }
    </style>
</head>
<body>
    <h1>Gerador de JSON (Tipos Únicos e Duplos - Com Redundâncias)</h1>
    <p id="status">Clique para gerar o JSON com as combinações de tipos únicos e duplos, incluindo redundâncias como Aço/Água e Água/Aço.</p>
    <button id="generateBtn">Gerar JSON Otimizado</button>
    <textarea id="jsonOutput" readonly placeholder="O resultado do JSON otimizado aparecerá aqui..."></textarea>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const generateBtn = document.getElementById('generateBtn');
            const jsonOutput = document.getElementById('jsonOutput');
            const statusDiv = document.getElementById('status');
            const jsonUrl = 'https://raw.githubusercontent.com/nowadraco/bloggerpoke/refs/heads/main/src/data/gamemaster/tipos_poke.json';

            async function generateAllTypeCombinationsJson() {
                try {
                    generateBtn.disabled = true;
                    statusDiv.textContent = 'Buscando dados...';
                    jsonOutput.value = '';
                    const response = await fetch(jsonUrl);
                    if (!response.ok) throw new Error('Falha na rede.');
                    const singleTypeData = await response.json();
                    statusDiv.textContent = 'Calculando combinações...';
                    
                    const allTypes = singleTypeData.map(t => t.tipo).sort();
                    const allResults = [];

                    // Adicionar tipos únicos primeiro
                    singleTypeData.forEach(typeDef => {
                        const combinationObject = {
                            tipos: [typeDef.tipo],
                            defesa: typeDef.defesa
                        };
                        // Normaliza os objetos de defesa para remover chaves vazias ou arrays vazios
                        if(Object.keys(combinationObject.defesa.fraqueza || {}).length === 0) delete combinationObject.defesa.fraqueza;
                        if(Object.keys(combinationObject.defesa.resistencia || {}).length === 0) delete combinationObject.defesa.resistencia;
                        if(Object.keys(combinationObject.defesa.normal || {}).length === 0) delete combinationObject.defesa.normal;
                        if(combinationObject.defesa.imunidade && combinationObject.defesa.imunidade.length === 0) delete combinationObject.defesa.imunidade;
                        allResults.push(combinationObject);
                    });


                    // Lógica para gerar todas as combinações duplas (incluindo A/B e B/A)
                    for (let i = 0; i < allTypes.length; i++) {
                        for (let j = 0; j < allTypes.length; j++) {
                            const type1Name = allTypes[i];
                            const type2Name = allTypes[j];

                            // Se os tipos são iguais, já foram adicionados como tipo único, então pule a DUPLICATA DE COMBINAÇÃO
                            // Mas não se for para um tipo diferente do original.
                            if (type1Name === type2Name) {
                                continue; 
                            }

                            const defense1Data = singleTypeData.find(t => t.tipo === type1Name).defesa;
                            const defense2Data = singleTypeData.find(t => t.tipo === type2Name).defesa;
                            
                            const finalMultipliers = {};
                            allTypes.forEach(attackingType => {
                                const mult1 = getMultiplier(defense1Data, attackingType);
                                const mult2 = getMultiplier(defense2Data, attackingType);
                                finalMultipliers[attackingType] = mult1 * mult2;
                            });

                            const combinationObject = {
                                tipos: [type1Name, type2Name],
                                defesa: {fraqueza: {}, resistencia: {}, imunidade: [], normal: {}}
                            };

                            for (const attackingType in finalMultipliers) {
                                const mult = finalMultipliers[attackingType];
                                const roundedMult = Math.round(mult * 1000) / 1000; // Arredonda para 3 casas decimais
                                const multKey = `${roundedMult}x`;

                                if (roundedMult > 1) {
                                    if (!combinationObject.defesa.fraqueza[multKey]) combinationObject.defesa.fraqueza[multKey] = [];
                                    combinationObject.defesa.fraqueza[multKey].push(attackingType);
                                } else if (roundedMult < 1 && roundedMult > 0) {
                                    if (!combinationObject.defesa.resistencia[multKey]) combinationObject.defesa.resistencia[multKey] = [];
                                    combinationObject.defesa.resistencia[multKey].push(attackingType);
                                } else if (roundedMult === 0) {
                                    combinationObject.defesa.imunidade.push(attackingType);
                                } else if (roundedMult === 1) {
                                    if (!combinationObject.defesa.normal[multKey]) combinationObject.defesa.normal[multKey] = [];
                                    combinationObject.defesa.normal[multKey].push(attackingType);
                                }
                            }

                            // Normaliza os objetos de defesa para remover chaves vazias ou arrays vazios
                            if(Object.keys(combinationObject.defesa.fraqueza).length === 0) delete combinationObject.defesa.fraqueza;
                            if(Object.keys(combinationObject.defesa.resistencia).length === 0) delete combinationObject.defesa.resistencia;
                            if(Object.keys(combinationObject.defesa.normal).length === 0) delete combinationObject.defesa.normal;
                            if(combinationObject.defesa.imunidade.length === 0) delete combinationObject.defesa.imunidade;

                            allResults.push(combinationObject);
                        }
                    }

                    // *** REMOVIDA A LÓGICA DE REMOÇÃO DE DUPLICATAS ***
                    // Isso garante que ["Aço", "Água"] e ["Água", "Aço"] serão mantidos.

                    jsonOutput.value = JSON.stringify(allResults, null, 2);
                    statusDiv.textContent = `JSON gerado com sucesso para ${allResults.length} combinações (únicas e duplas, com redundâncias)!`;
                } catch (error) {
                    statusDiv.textContent = `Ocorreu um erro: ${error.message}`;
                } finally {
                    generateBtn.disabled = false;
                }
            }

            function getMultiplier(defenseData, attackingType) {
                if (!defenseData) return 1.0;
                // Verifique primeiro a imunidade
                if (defenseData.imunidade && defenseData.imunidade.includes(attackingType)) return 0.0;
                
                for (const k in defenseData.fraqueza) if (defenseData.fraqueza[k].includes(attackingType)) return parseFloat(k);
                for (const k in defenseData.resistencia) if (defenseData.resistencia[k].includes(attackingType)) return parseFloat(k);
                for (const k in defenseData.normal) if (defenseData.normal[k].includes(attackingType)) return parseFloat(k);
                return 1.0; // Padrão se não encontrado em nenhuma categoria
            }
            
            generateBtn.addEventListener('click', generateAllTypeCombinationsJson);
        });
    </script>
</body>
</html>