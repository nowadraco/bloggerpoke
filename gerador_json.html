<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de JSON para Tipos Duplos</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f0f0f0;
            color: #333;
            max-width: 90%;
            margin: 20px auto;
            padding: 20px;
        }
        h1 { text-align: center; }
        button {
            display: block;
            width: 250px;
            padding: 15px;
            font-size: 18px;
            margin: 20px auto;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            text-align: center;
            font-style: italic;
            color: #555;
            margin-bottom: 20px;
        }
        textarea {
            width: 100%;
            height: 60vh;
            margin-top: 10px;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <h1>Gerador de JSON para Tipos Duplos</h1>
    <p id="status">Clique no botão para buscar os dados e gerar o JSON com todas as combinações de tipos duplos.</p>
    <button id="generateBtn">Gerar JSON Completo</button>
    <textarea id="jsonOutput" readonly placeholder="O resultado do JSON aparecerá aqui..."></textarea>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const generateBtn = document.getElementById('generateBtn');
            const jsonOutput = document.getElementById('jsonOutput');
            const statusDiv = document.getElementById('status');
            const jsonUrl = 'https://raw.githubusercontent.com/nowadraco/bloggerpoke/refs/heads/main/src/data/gamemaster/tipos_poke.json';

            generateBtn.addEventListener('click', generateDualTypeJson);

            async function generateDualTypeJson() {
                try {
                    // Desabilita o botão e atualiza o status
                    generateBtn.disabled = true;
                    statusDiv.textContent = 'Buscando dados dos tipos...';
                    jsonOutput.value = '';

                    // 1. BUSCAR OS DADOS ORIGINAIS
                    const response = await fetch(jsonUrl);
                    if (!response.ok) throw new Error('Falha ao buscar dados da rede.');
                    const singleTypeData = await response.json();
                    
                    statusDiv.textContent = 'Calculando todas as combinações... Por favor, aguarde.';

                    const allTypes = singleTypeData.map(t => t.tipo).sort();
                    const dualTypeResults = [];

                    // 2. ITERAR SOBRE TODAS AS COMBINAÇÕES ÚNICAS
                    // Usamos j = i + 1 para evitar duplicatas (Fogo/Voador) e pares do mesmo tipo (Fogo/Fogo)
                    for (let i = 0; i < allTypes.length; i++) {
                        for (let j = i + 1; j < allTypes.length; j++) {
                            const type1Name = allTypes[i];
                            const type2Name = allTypes[j];

                            const defense1Data = singleTypeData.find(t => t.tipo === type1Name).defesa;
                            const defense2Data = singleTypeData.find(t => t.tipo === type2Name).defesa;
                            
                            const finalMultipliers = {};
                            
                            // Calcula o multiplicador combinado para cada tipo de ataque
                            allTypes.forEach(attackingType => {
                                const mult1 = getMultiplier(defense1Data, attackingType);
                                const mult2 = getMultiplier(defense2Data, attackingType);
                                finalMultipliers[attackingType] = mult1 * mult2;
                            });

                            // 3. ESTRUTURAR O OBJETO JSON PARA A COMBINAÇÃO
                            const dualTypeObject = {
                                tipos: [type1Name, type2Name],
                                defesa: {
                                    fraqueza: {},
                                    resistencia: {},
                                    imunidade: []
                                }
                            };

                            for (const attackingType in finalMultipliers) {
                                const mult = finalMultipliers[attackingType];
                                const roundedMult = Math.round(mult * 1000) / 1000;
                                const multKey = `${roundedMult}x`;

                                if (roundedMult > 1) {
                                    if (!dualTypeObject.defesa.fraqueza[multKey]) {
                                        dualTypeObject.defesa.fraqueza[multKey] = [];
                                    }
                                    dualTypeObject.defesa.fraqueza[multKey].push(attackingType);
                                } else if (roundedMult < 1 && roundedMult > 0) {
                                    if (!dualTypeObject.defesa.resistencia[multKey]) {
                                        dualTypeObject.defesa.resistencia[multKey] = [];
                                    }
                                    dualTypeObject.defesa.resistencia[multKey].push(attackingType);
                                } else if (roundedMult === 0) {
                                    dualTypeObject.defesa.imunidade.push(attackingType);
                                }
                            }
                            
                            // Limpa chaves vazias e ordena os tipos dentro de cada multiplicador
                            for (const key in dualTypeObject.defesa.fraqueza) {
                                dualTypeObject.defesa.fraqueza[key].sort();
                            }
                            for (const key in dualTypeObject.defesa.resistencia) {
                                dualTypeObject.defesa.resistencia[key].sort();
                            }
                            if(dualTypeObject.defesa.imunidade.length === 0) delete dualTypeObject.defesa.imunidade;


                            dualTypeResults.push(dualTypeObject);
                        }
                    }
                    
                    // 4. EXIBIR O JSON FINAL
                    jsonOutput.value = JSON.stringify(dualTypeResults, null, 2); // O '2' formata o JSON de forma legível
                    statusDiv.textContent = `JSON gerado com sucesso para ${dualTypeResults.length} combinações! Você pode copiar o resultado abaixo.`;

                } catch (error) {
                    statusDiv.textContent = `Ocorreu um erro: ${error.message}`;
                    console.error('Erro ao gerar JSON:', error);
                } finally {
                    // Habilita o botão novamente
                    generateBtn.disabled = false;
                }
            }

            // Função auxiliar para obter o multiplicador de um único tipo
            function getMultiplier(defenseData, attackingType) {
                if (!defenseData) return 1.0;
                if (defenseData.fraqueza && defenseData.fraqueza['1.6x']?.includes(attackingType)) return 1.6;
                if (defenseData.resistencia) {
                    if (defenseData.resistencia['0.625x']?.includes(attackingType)) return 0.625;
                    if (defenseData.resistencia['0.391x']?.includes(attackingType)) return 0.391;
                }
                if (defenseData.imunidade && defenseData.imunidade['0x']?.includes(attackingType)) return 0;
                return 1.0;
            }
        });
    </script>
</body>
</html>